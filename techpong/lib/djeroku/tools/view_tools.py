from coffin.shortcuts import HttpResponse
from django.core.paginator import Paginator, EmptyPage, InvalidPage
from django.utils.translation import ugettext as _, ungettext as _n
try: import simplejson as json
except ImportError: import json

def json_response(success, mimetype='application/json', **kwargs):
    """Accepts boolean success and any other keyword arguments
    and returns an HttpResponse with a json encoded object."""
    response = {'success': success}
    response.update(kwargs)
    return HttpResponse(json.dumps(response), mimetype=mimetype)

def raw_json_response(response, mimetype='application/json'):
    """Accepts an object and returns an HttpResponse
    with it encoded, using the specified mimetype or application/json."""
    return HttpResponse(json.dumps(response), mimetype=mimetype)

# this should probably be a decorator
def validate_required_exist(request, required_fields, check_get=False):
    """Accepts a list of fields and checks that they are
    available in the POST variable. If check_get is True,
    will also check for the fields in the GET variable before
    failing. If all the fields are found, returns True, otherwise
    returns the first missing field it finds."""
    for field in required_fields:
        if field not in request.POST and (not check_get or field not in request.GET):
            return field
    return True

def validate_required(get_or_post, required_fields, error_messages=None):
    """
    Much more in depth validation of required fields. Each field must be found
    in the given get_or_post dictionary and can optionally supply custom
    validation functions, clean functions, and error messages.
    Returns a tuple in the form:
        (Success, {field: clean/error})

    Basic Usage Example:
        required_fields = {
            'object_id': { 'validation': lambda a: a.isdigit() },
            'object_type': { 'validation': lambda a: a.isalnum() and a.strip() != '' }
        }
        success, clean = validate_required(request.POST, required_fields)
        if not success:
            for field, error in clean:
                print "Invalid %s: %s" % (field, error)
        else:
            object_id = clean['object_id']
            object_type = clean['object_type']


    required_fields are specified using a dictionary in the following format:
    dict[field] = {
        'validation': function to validate value,
        'clean': function to clean value,
        'validation_failed_message': 'translated string with optional {field} format',
        'clean_failed_message': 'same as validation_failed_message but for clean',
    }

    All of the keys for a field are optional. Missing fields will simply use
    defaults. The default error messages are all localizable using gettext.

    Each field will be checked that
        1. it exists in the get_or_post dictionary
        2. if a validation function is available, the function returns true when
            called with the value of the field
        3. if a clean function is available, no exception is raised when
            called with the value of the field

    If the validation function fails the error message will be generated by
    trying the following in order:
        1. using validation_failed_message (can include {field})
        2. using the validation_failed error_message in the error_messages dict

    Localizable error messages are included, but you can pass in a dictionary
    of your own translated error messages if you want to customize the output.
    """

    default_error_messages = {
        'missing_field': _('Missing Required Field'),
        'validation_failed': _('Validation Failed'),
        'clean_failed': _('Validation Failed')
    }
    default_error_messages.update(error_messages or {})
    error_messages = default_error_messages

    failures = {}
    clean = {}

    for field, field_info in required_fields.iteritems():
        # check that field exists
        if field not in get_or_post:
            failures[field] = error_messages['missing_field']
            continue

        # get the raw value from get/post dict
        field_raw_value = get_or_post[field]

        # validate field if function is available
        if 'validation' in field_info \
                and not field_info['validation'](field_raw_value):

            # get correct validation failure message
            message = error_messages['validation_failed']
            if 'validation_failed_message' in field_info:
                message = field_info['validation_failed_message'].format(
                        **dict(field = field))

            # save failure and move to next field
            failures[field] = message
            continue

        # clean field if function is available
        if 'clean' in field_info:
            try:
                clean[field] = field_info['clean'](field_raw_value)
            except:
                # get correct clean failure message
                message = error_messages['clean_failed']
                if 'clean_failed_message' in field_info:
                    message = field_info['clean_failed_message'].format(
                            **dict(field = field))

                # save message/return failure
                failures[field] = message
                continue

        # no clean function, use raw
        else:
            clean[field] = field_raw_value

    # failures
    if len(failures) > 0:
        return (False, failures)

    # no failures, return clean field dict
    return (True, clean)


# http://www.lightbird.net/dbe/forum1.html
def create_paginator(request, items, num_items):
    """Create and return a paginator."""
    paginator = Paginator(items, num_items)
    try: page = int(request.GET.get("page", '1'))
    except ValueError: page = 1

    try:
        items = paginator.page(page)
    except (InvalidPage, EmptyPage):
        items = paginator.page(paginator.num_pages)
    return items
